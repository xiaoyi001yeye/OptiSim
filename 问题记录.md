# OptiSim - 问题与改进记录

本文档记录了在代码审查期间发现的潜在逻辑问题和建议的改进点。

## 修订历史

| 记录日期   | 版本/提交哈希 | 记录人 |
| :--------- | :------------ | :----- |
| 2025-07-14 | 562f3fb       | Gemini |

---

### 待处理问题列表

#### 1. 关键输入值为零或负数时程序静默失败

- **问题描述:** 
  当用户将“工作距离”、“物体宽度”或“相机分辨率”等关键参数输入为0或负数时，`calculate()` 函数会因为保护条件 `if (wd <= 0 || objectW <= 0 || coverage <= 0) return;` 或除零错误（如 `accuracy = actualFovW / resolutionW`）而提前退出或计算出 `Infinity`。这两种情况下，页面不会向用户提供任何反馈，计算结果区域的数值也只是停止更新或显示为 `Infinity`，可能会让用户感到困惑。

- **影响:** 
  用户体验不佳。用户不知道是他们的输入有问题，还是计算器坏了。

- **改进建议:** 
  增加一个专门的UI元素（例如，一个状态栏或一个模态对话框），当检测到无效输入时，明确地提示用户“请输入大于零的有效数值”，而不是静默失败。

#### 2. 传感器尺寸解析的硬编码依赖

- **问题描述:** 
  JavaScript代码通过 `value.split(',')` 来解析传感器的宽高，如 `const [sensorH, sensorW] = elements.sensor.value.split(',').map(parseFloat);`。此方法强依赖于HTML中 `<option>` 的 `value` 属性必须是 `"height,width"` 的格式。

- **影响:** 
  代码不够健壮。如果将来在HTML中修改、增加新的传感器尺寸，或不小心改变了 `value` 的格式（例如，增加了空格 `"h, w"` 或颠倒了顺序 `"w,h"`），该解析逻辑就会出错，导致所有计算失败。

- **改进建议:** 
  采用更健壮的数据格式。例如，可以使用 `data-*` 属性将宽高分开存储：`<option value="13.2,8.8" data-w="13.2" data-h="8.8">1" (13.2 x 8.8 mm)</option>`。然后在JavaScript中通过 `element.selectedOptions[0].dataset.w` 和 `element.selectedOptions[0].dataset.h` 来获取值，这样更清晰且不易出错。

#### 3. 3D模型中物体深度的假设

- **问题描述:** 
  3D示意图中的“被摄物体”是一个立方体，其深度（Z轴方向的尺寸）是根据其宽度和高度的平均值估算出来的：`objectBox.scale.set(scaledObjW, scaledObjH, (scaledObjW + scaledObjH) / 2);`。这是一个硬编码的假设，因为UI上并没有让用户输入物体“深度”的选项。

- **影响:** 
  可视化结果可能与用户的实际物体有出入，虽然这对于当前计算器的核心功能（2D成像参数计算）影响不大，但可能会引起误解。

- **改进建议:** 
  - **短期:** 在代码中为这个估算值增加一条注释，说明这是一个为了可视化而做的假设。
  - **长期:** 可以在UI上增加一个可选的“物体深度(mm)”输入框，如果用户填写了，就使用该值来渲染3D模型，使其更加精确。
